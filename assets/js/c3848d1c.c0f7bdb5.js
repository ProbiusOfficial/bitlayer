"use strict";(self.webpackChunkbitlayer=self.webpackChunkbitlayer||[]).push([[589],{2872:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=i(4848),n=i(8453);const r={},o="Bitlayer",s={id:"about bitlayer/index",title:"Bitlayer",description:"Technical Architecture",source:"@site/docs/about bitlayer/index.md",sourceDirName:"about bitlayer",slug:"/about bitlayer/",permalink:"/bitlayer/docs/about bitlayer/",draft:!1,unlisted:!1,editUrl:"https://github.com/bitlayer-org/bitlayer/docs/docs/about bitlayer/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"About",permalink:"/bitlayer/docs/category/about"},next:{title:"Quick start",permalink:"/bitlayer/docs/category/quick-start"}},c={},l=[{value:"Technical Architecture",id:"technical-architecture",level:2}];function h(e){const t={h1:"h1",h2:"h2",p:"p",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"bitlayer",children:"Bitlayer"}),"\n",(0,a.jsx)(t.h2,{id:"technical-architecture",children:"Technical Architecture"}),"\n",(0,a.jsx)(t.p,{children:"static/img/bitlayer roadmap.png"}),"\n",(0,a.jsx)(t.p,{children:"Bitlayer's solution synthesizes the technical characteristics of BitVM, DLC|BitVM, and various XVMs (such as EVM, MoveVM), addressing three major challenges: Layer 1 verification, asset bridging, and enriching state transition expressions."}),"\n",(0,a.jsx)(t.p,{children:"From an architectural standpoint, Bitlayer is a fairly typical example of a Rollup-equivalent model. To adapt to Bitcoin's unique programming model, BitVM has been introduced as a component for state challenges. Additionally, DLC|BitVM has been incorporated as a cross-chain component for messaging/assets, and the sequencer component's XVM, in theory, can support any Turing-complete programming language."}),"\n",(0,a.jsx)(t.p,{children:"The security of bridge assets has always been a key for Layer 2 solutions, with the core issue being the method of asset control. The most common industry approach is for Layer 2 platform operators to set up multi-signature accounts based on MPC-TSS (Multi-Party Computation - Threshold Signature Scheme) or Schnorr technology, into which users transfer their assets."}),"\n",(0,a.jsx)(t.p,{children:"This traditional approach results in users completely losing control of their assets, while the platform's multi-signature management capabilities can impact the security of those assets. In the wake of certain extreme cases, users have become dissatisfied with these types of multi-signature solutions. Models like DLC|BitVM that encompass two-party game scenarios may be a better direction. Leveraging DLC|BitVM technology, users could retain partial control over their assets and potentially achieve a secure escape with their assets."}),"\n",(0,a.jsx)(t.p,{children:"The verification of Layer 2 state transitions operates on a principle comparable to proving one's innocence\u2014an inherently secure process. Theoretically, the choice of network used for state verification determines the security level of the Layer 2 network. As one of the most secure networks available, using Bitcoin's base layer for verification enables Bitlayer to inherit Bitcoin's robust security measures, achieving an equivalent level of security to Bitcoin itself. The introduction of the BitVM paradigm challenges the conventional view that complex computations cannot be performed on Bitcoin, offering a new pathway for executing Layer 2 state verifications on the Bitcoin network."}),"\n",(0,a.jsx)(t.p,{children:"In terms of Layer 1 verification, autonomous asset escape, secure asset bridging, and EVM compatibility, Bitlayer exhibits superior performance compared to existing Bitcoin Layer 2 solutions such as Lightning Network and Stacks."})]})}function u(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>s});var a=i(6540);const n={},r=a.createContext(n);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);