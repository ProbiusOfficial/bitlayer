"use strict";(self.webpackChunkbitlayer=self.webpackChunkbitlayer||[]).push([[589],{2872:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=i(4848),a=i(8453);const s={},r="Bitlayer",o={id:"about bitlayer/index",title:"Bitlayer",description:"Technical Architecture",source:"@site/docs/about bitlayer/index.md",sourceDirName:"about bitlayer",slug:"/about bitlayer/",permalink:"/bitlayer/docs/about bitlayer/",draft:!1,unlisted:!1,editUrl:"https://github.com/bitlayer-org/bitlayer/docs/docs/about bitlayer/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"About",permalink:"/bitlayer/docs/category/about"},next:{title:"Quick start",permalink:"/bitlayer/docs/category/quick-start"}},l={},c=[{value:"Technical Architecture",id:"technical-architecture",level:2},{value:"Roadmap",id:"roadmap",level:2},{value:"First Stage: Bitlayer Mainnet-V1",id:"first-stage-bitlayer-mainnet-v1",level:3},{value:"Second Stage: Bitlayer Mainnet-V2",id:"second-stage-bitlayer-mainnet-v2",level:3},{value:"Third Stage: Bitlayer Mainnet V3",id:"third-stage-bitlayer-mainnet-v3",level:3},{value:"Use Case Ideas",id:"use-case-ideas",level:2}];function h(e){const t={h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"bitlayer",children:"Bitlayer"}),"\n",(0,n.jsx)(t.h2,{id:"technical-architecture",children:"Technical Architecture"}),"\n",(0,n.jsx)(t.p,{children:"static/img/bitlayer roadmap.png"}),"\n",(0,n.jsx)(t.p,{children:"Bitlayer's solution synthesizes the technical characteristics of BitVM, DLC|BitVM, and various XVMs (such as EVM, MoveVM), addressing three major challenges: Layer 1 verification, asset bridging, and enriching state transition expressions."}),"\n",(0,n.jsx)(t.p,{children:"From an architectural standpoint, Bitlayer is a fairly typical example of a Rollup-equivalent model. To adapt to Bitcoin's unique programming model, BitVM has been introduced as a component for state challenges. Additionally, DLC|BitVM has been incorporated as a cross-chain component for messaging/assets, and the sequencer component's XVM, in theory, can support any Turing-complete programming language."}),"\n",(0,n.jsx)(t.p,{children:"The security of bridge assets has always been a key for Layer 2 solutions, with the core issue being the method of asset control. The most common industry approach is for Layer 2 platform operators to set up multi-signature accounts based on MPC-TSS (Multi-Party Computation - Threshold Signature Scheme) or Schnorr technology, into which users transfer their assets."}),"\n",(0,n.jsx)(t.p,{children:"This traditional approach results in users completely losing control of their assets, while the platform's multi-signature management capabilities can impact the security of those assets. In the wake of certain extreme cases, users have become dissatisfied with these types of multi-signature solutions. Models like DLC|BitVM that encompass two-party game scenarios may be a better direction. Leveraging DLC|BitVM technology, users could retain partial control over their assets and potentially achieve a secure escape with their assets."}),"\n",(0,n.jsx)(t.p,{children:"The verification of Layer 2 state transitions operates on a principle comparable to proving one's innocence\u2014an inherently secure process. Theoretically, the choice of network used for state verification determines the security level of the Layer 2 network. As one of the most secure networks available, using Bitcoin's base layer for verification enables Bitlayer to inherit Bitcoin's robust security measures, achieving an equivalent level of security to Bitcoin itself. The introduction of the BitVM paradigm challenges the conventional view that complex computations cannot be performed on Bitcoin, offering a new pathway for executing Layer 2 state verifications on the Bitcoin network."}),"\n",(0,n.jsx)(t.p,{children:"In terms of Layer 1 verification, autonomous asset escape, secure asset bridging, and EVM compatibility, Bitlayer exhibits superior performance compared to existing Bitcoin Layer 2 solutions such as Lightning Network and Stacks."}),"\n",(0,n.jsx)(t.h2,{id:"roadmap",children:"Roadmap"}),"\n",(0,n.jsx)(t.p,{children:"The vision of Bitlayer will be realized through the rollout of a mainnet in multiple stages, with each phase designed to enhance the user experience and bolster security through cryptographic proof of Bitcoin consensus and onchain activity."}),"\n",(0,n.jsx)(t.h3,{id:"first-stage-bitlayer-mainnet-v1",children:"First Stage: Bitlayer Mainnet-V1"}),"\n",(0,n.jsx)(t.p,{children:"In this initial phase, Bitlayer will support the cross-chain movement of BTC/BRC-20 assets between the Bitcoin mainnet and Bitlayer, and other mainstream assets, thereby enriching the overall value of the Bitlayer ecosystem."}),"\n",(0,n.jsx)(t.p,{children:"During this stage, we will prioritize offering a 100% EVM-compatible development kit and ecosystem support, enabling developers to quickly build, test, and deploy applications on Bitlayer. Solidity applications can be seamlessly migrated, providing early users with the benefits of low gas fees and an extensible Bitcoin framework."}),"\n",(0,n.jsx)(t.h3,{id:"second-stage-bitlayer-mainnet-v2",children:"Second Stage: Bitlayer Mainnet-V2"}),"\n",(0,n.jsx)(t.p,{children:"In this phase, we plan to introduce a Sequencer+DA model, which, based on the DLC|BitVM technical protocol, secures user asset deposits and withdrawals. Additionally, utilizing multisig oracles for challenges and DLC-Attestors controlled by multisig for asset escape will be implemented."}),"\n",(0,n.jsx)(t.p,{children:"By leveraging the vast network and security of Bitcoin, Bitlayer will continuously lead with the highest security standards, offering users enhanced flexibility and an improved onchain experience through network upgrades."}),"\n",(0,n.jsx)(t.h3,{id:"third-stage-bitlayer-mainnet-v3",children:"Third Stage: Bitlayer Mainnet V3"}),"\n",(0,n.jsx)(t.p,{children:"In this phase, our aim is to implement OP challenges based on BitVM, along with decentralized DLC-Attestors for asset escape.\nUpon the completion of this third stage, Bitlayer\u2019s final mainnet will be fully deployed, achieving the network's original goals\u2014Bitcoin-equivalent security combined with Turing completeness."}),"\n",(0,n.jsx)(t.p,{children:"This version is set to elevate the security standards of Bitcoin Layer 2 to an unprecedented level."}),"\n",(0,n.jsx)(t.h2,{id:"use-case-ideas",children:"Use Case Ideas"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Decentralized Bitcoin interest (convert staking rewards of other tokens to Bitcoin)"}),"\n",(0,n.jsx)(t.li,{children:"Zap money (fast, micro-transfers)"}),"\n",(0,n.jsx)(t.li,{children:"Account abstraction for BTC wallets"}),"\n",(0,n.jsx)(t.li,{children:"Advanced BTC NFTs with secure swaps"}),"\n",(0,n.jsxs)(t.li,{children:["Bridge","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Bridging assets to Bitcoin as BRC20s or"}),"\n",(0,n.jsx)(t.li,{children:"Bridging BRC20 from Bitcoin to other ecosystems"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:"Ordinals marketplace"}),"\n",(0,n.jsx)(t.li,{children:"Bitlayer-scriptions"}),"\n",(0,n.jsx)(t.li,{children:"AI & Bitcoin integrations"}),"\n",(0,n.jsx)(t.li,{children:"ZK Rust smart contracts"}),"\n",(0,n.jsx)(t.li,{children:"BTC DEXes, lending & derivatives"}),"\n",(0,n.jsx)(t.li,{children:"BTC-backed stablecoins"}),"\n",(0,n.jsx)(t.li,{children:"Tokenized mining & hashrate markets"}),"\n",(0,n.jsx)(t.li,{children:"DAOs & BTC treasuries"}),"\n",(0,n.jsx)(t.li,{children:"Gamefi incorporating btc as in-dapp currency"}),"\n",(0,n.jsx)(t.li,{children:"socialFi, build a Farcaster frame or something with Nostr"}),"\n",(0,n.jsx)(t.li,{children:"BTC for autonomous agents"}),"\n",(0,n.jsx)(t.li,{children:"BTC for DA & checkpoints for L2 chains\ufb01"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var n=i(6540);const a={},s=n.createContext(a);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);